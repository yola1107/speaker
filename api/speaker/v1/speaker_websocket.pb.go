// Code generated by protoc-gen-go-websocket. DO NOT EDIT.
// versions:
// - protoc-gen-go-websocket v2.8.6
// - protoc            v3.6.1
// source: speaker/v1/speaker.proto

package v1

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
import (
	"context"

	"github.com/yola1107/kratos/v2/library/task"
	"github.com/yola1107/kratos/v2/transport/websocket"

	"google.golang.org/protobuf/proto"
)

var websocketLoopIns *task.Loop

func GetLoop() *task.Loop { return websocketLoopIns }

// SpeakerWebsocketServer is the server API for Speaker service.
type SpeakerWebsocketServer interface {
	IsLoopFunc(f string) (isLoop bool)
	SayHelloReq(context.Context, *HelloRequest) (*HelloReply, error)
	SayHello2Req(context.Context, *Hello2Request) (*Hello2Reply, error)
}

func RegisterSpeakerWebsocketServer(s *websocket.Server, srv SpeakerWebsocketServer) {
	websocketLoopIns = s.GetLoop()
	s.RegisterService(&Speaker_Websocket_ServiceDesc, srv)
}

func _Speaker_SayHelloReq_Websocket_Handler(srv interface{}, ctx context.Context, data []byte, interceptor websocket.UnaryServerInterceptor) ([]byte, error) {
	in := new(HelloRequest)
	if err := proto.Unmarshal(data, in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		out, err := srv.(SpeakerWebsocketServer).SayHelloReq(ctx, in)
		data, _ := proto.Marshal(out)
		return data, err
	}
	info := &websocket.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helloworld.v1.Speaker/SayHelloReq",
	}
	handler := func(ctx context.Context, req interface{}) ([]byte, error) {
		out := new(HelloReply)
		var err error
		if srv.(SpeakerWebsocketServer).IsLoopFunc("SayHelloReq") {
			rspChan := make(chan *HelloReply)
			errChan := make(chan error)
			websocketLoopIns.Post(func() {
				resp, err := srv.(SpeakerWebsocketServer).SayHelloReq(ctx, req.(*HelloRequest))
				rspChan <- resp
				errChan <- err
			})
			out = <-rspChan
			err = <-errChan
		} else {
			out, err = srv.(SpeakerWebsocketServer).SayHelloReq(ctx, req.(*HelloRequest))
		}
		if out != nil {
			data, _ := proto.Marshal(out)
			return data, err
		}
		return nil, err
	}
	return interceptor(ctx, in, info, handler)
}

func _Speaker_SayHello2Req_Websocket_Handler(srv interface{}, ctx context.Context, data []byte, interceptor websocket.UnaryServerInterceptor) ([]byte, error) {
	in := new(Hello2Request)
	if err := proto.Unmarshal(data, in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		out, err := srv.(SpeakerWebsocketServer).SayHello2Req(ctx, in)
		data, _ := proto.Marshal(out)
		return data, err
	}
	info := &websocket.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helloworld.v1.Speaker/SayHello2Req",
	}
	handler := func(ctx context.Context, req interface{}) ([]byte, error) {
		out := new(Hello2Reply)
		var err error
		if srv.(SpeakerWebsocketServer).IsLoopFunc("SayHello2Req") {
			rspChan := make(chan *Hello2Reply)
			errChan := make(chan error)
			websocketLoopIns.Post(func() {
				resp, err := srv.(SpeakerWebsocketServer).SayHello2Req(ctx, req.(*Hello2Request))
				rspChan <- resp
				errChan <- err
			})
			out = <-rspChan
			err = <-errChan
		} else {
			out, err = srv.(SpeakerWebsocketServer).SayHello2Req(ctx, req.(*Hello2Request))
		}
		if out != nil {
			data, _ := proto.Marshal(out)
			return data, err
		}
		return nil, err
	}
	return interceptor(ctx, in, info, handler)
}

var Speaker_Websocket_ServiceDesc = websocket.ServiceDesc{
	ServiceName: "helloworld.v1.Speaker",
	HandlerType: (*SpeakerWebsocketServer)(nil),
	Methods: []websocket.MethodDesc{
		{
			MethodName: "SayHelloReq",
			Handler:    _Speaker_SayHelloReq_Websocket_Handler,
			Ops:        1001,
		},
		{
			MethodName: "SayHello2Req",
			Handler:    _Speaker_SayHello2Req_Websocket_Handler,
			Ops:        1003,
		},
	},
}
