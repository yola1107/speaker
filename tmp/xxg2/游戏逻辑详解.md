# XXG2 游戏逻辑详解

## 🎮 游戏概述

**游戏名称**：吸血鬼（XXG2）  
**游戏类型**：Ways 玩法老虎机  
**网格大小**：4行 × 5列 = 20个符号位置  
**中奖方式**：连续相同符号（从左到右，至少3个）  

---

## 🎯 符号说明

### 符号类型（共12种）

| ID | 符号名称 | 类型 | 3个倍率 | 4个倍率 | 5个倍率 |
|----|----------|------|---------|---------|---------|
| 0 | 空白 | 特殊 | - | - | - |
| 1 | J | 低倍率 | 2 | 3 | 5 |
| 2 | Q | 低倍率 | 2 | 3 | 5 |
| 3 | K | 低倍率 | 2 | 3 | 5 |
| 4 | A | 低倍率 | 2 | 3 | 5 |
| 5 | 十字架 | 中倍率 | 4 | 7 | 10 |
| 6 | 酒杯 | 中倍率 | 6 | 10 | 15 |
| 7 | 小孩 | 高倍率 | 12 | 15 | 25 |
| 8 | 青年女人 | 高倍率 | 15 | 20 | 30 |
| 9 | 老头 | 高倍率 | 18 | 25 | 40 |
| **10** | **百搭 (Wild)** | **特殊** | 20 | 30 | 50 |
| **11** | **夺宝 (Treasure/Scatter)** | **特殊** | - | - | - |

### 特殊符号作用

#### 🃏 百搭 (Wild, ID=10)
- **作用**：可以替代任何符号（除了夺宝符号）形成中奖
- **独立中奖**：连续的百搭符号也可以独立中奖
- **倍率**：最高（20/30/50）

#### 💎 夺宝 (Treasure/Scatter, ID=11)
- **作用**：触发免费游戏
- **不参与中奖**：不计入 Ways 中奖
- **触发条件**：
  - 基础游戏：≥3个夺宝符号 → 触发免费游戏
  - 免费游戏：每个夺宝符号 → 增加免费次数

---

## 🎲 游戏流程

### 1. 整体流程

```
用户下注
  ↓
【初始化】initialize()
  ├─ 生成订单号
  ├─ 验证余额
  └─ 重置客户端状态
  ↓
【生成符号】initSpinSymbol()
  ├─ 选择 RealData（基础/免费）
  ├─ 每列随机起始位置
  └─ 生成 4×5 符号网格
  ↓
【查找中奖】findWinInfos()
  ├─ 遍历所有符号（1-10）
  ├─ 检查 Ways 中奖
  └─ 记录中奖信息
  ↓
【处理中奖】processWinInfos()
  ├─ 计算每个符号的倍率
  ├─ 计算总线倍数
  └─ 构建中奖结果
  ↓
【更新状态】updateBaseStepResult() / updateFreeStepResult()
  ├─ 基础游戏：检查免费触发
  └─ 免费游戏：增加/扣除次数
  ↓
【返回结果】
  ├─ 符号网格
  ├─ 中奖信息
  ├─ 奖金金额
  └─ 免费游戏状态
```

---

## 🏆 中奖逻辑（Ways 玩法）

### 核心规则

1. **从左到右**：必须从第1列开始连续
2. **至少3个**：最少需要3列连续匹配
3. **Ways 计算**：每列匹配的符号数量相乘

### 中奖判断算法

```go
func (s *betOrderService) findSymbolWinInfo(symbol int64) (*winInfo, bool) {
    lineCount := int64(1)  // Ways 倍数
    var positions []*position
    hasRealSymbol := false  // 是否有真实符号（非百搭）
    
    // 遍历每一列（从左到右）
    for col := int64(0); col < 5; col++ {
        count := int64(0)
        
        // 统计该列中匹配的符号数量
        for row := int64(0); row < 4; row++ {
            currSymbol := symbolGrid[row][col]
            
            // 关键：符号匹配 或 百搭符号
            if currSymbol == symbol || currSymbol == _wild {
                count++
                if currSymbol == symbol {
                    hasRealSymbol = true  // 记录有真实符号
                }
                positions = append(positions, &position{Row: row, Col: col})
            }
        }
        
        // 该列无匹配 → 中断
        if count == 0 {
            // 已经连续 ≥ 3 列，且有真实符号 → 中奖
            if col >= 3 && hasRealSymbol {
                return &winInfo{Symbol: symbol, SymbolCount: col, LineCount: lineCount}, true
            }
            return nil, false
        }
        
        // Ways 倍数：累乘每列的匹配数量
        lineCount *= count
        
        // 到达最后一列 → 全屏中奖
        if col == 4 && hasRealSymbol {
            return &winInfo{Symbol: symbol, SymbolCount: 5, LineCount: lineCount}, true
        }
    }
    
    return nil, false
}
```

### 中奖示例

#### 示例 1：基础中奖
```
符号网格：
  [3]  [3]  [3]  [8]  [9]
  [1]  [3]  [4]  [2]  [1]
  [5]  [3]  [5]  [7]  [8]
  [7]  [1]  [6]  [6]  [7]
   ↓    ↓    ↓
 列1  列2  列3  列4  列5

符号 3 中奖：
- 第1列：1个符号3
- 第2列：3个符号3
- 第3列：1个符号3
- 第4列：0个符号3 → 中断
→ 中奖：3个符号3，Ways = 1×3×1 = 3
→ 倍率：2（3个符号的基础倍率）
→ 总倍率 = 2 × 3 = 6
```

#### 示例 2：百搭参与中奖
```
符号网格：
  [8]  [10] [8]  [5]  [2]
  [3]  [8]  [10] [3]  [3]
  [6]  [8]  [5]  [4]  [4]
  [7]  [1]  [6]  [6]  [7]
        ↓    ↓
      百搭  百搭

符号 8 中奖：
- 第1列：1个符号8
- 第2列：2个（1个符号8 + 1个百搭）
- 第3列：2个（1个符号8 + 1个百搭）
- 第4列：0个符号8 → 中断
→ 中奖：3列，Ways = 1×2×2 = 4
→ 倍率：15（3列符号8的基础倍率）
→ 总倍率 = 15 × 4 = 60
```

#### 示例 3：全屏百搭
```
符号网格：
  [10] [10] [10] [10] [10]
  [10] [10] [10] [10] [10]
  [10] [10] [10] [10] [10]
  [10] [10] [10] [10] [10]
   ↓    ↓    ↓    ↓    ↓
  全是百搭

符号 10（百搭）中奖：
- 第1-5列：每列4个百搭
→ 中奖：5列，Ways = 4×4×4×4×4 = 1024
→ 倍率：50（5个百搭的基础倍率）
→ 总倍率 = 50 × 1024 = 51200
```

---

## 🔍 关键代码分析

### 1. findWinInfos() - 查找所有中奖

```go
func (s *betOrderService) findWinInfos() {
    var infos []*winInfo
    
    // 遍历符号 1 到 10（不包括 treasure=11）
    for symbol := _blank + 1; symbol < _treasure; symbol++ {
        var info *winInfo
        var ok bool
        
        if symbol != _wild {
            // 普通符号（1-9）
            info, ok = s.findSymbolWinInfo(symbol)
        } else {
            // 百搭符号（10）
            info, ok = s.findWildWinInfo(_wild)
        }
        
        if ok {
            infos = append(infos, info)
        }
    }
    
    s.winInfos = infos
}
```

**说明**：
- 遍历符号 1-10
- 跳过 treasure（11）
- 检查每个符号是否中奖
- 百搭符号使用独立的判断函数

### 2. findWildWinInfo() - 百搭独立中奖

```go
func (s *betOrderService) findWildWinInfo(symbol int64) (*winInfo, bool) {
    lineCount := int64(1)
    var positions []*position
    
    for col := int64(0); col < _colCount; col++ {
        count := int64(0)
        
        // 统计该列中百搭的数量
        for row := int64(0); row < _rowCount; row++ {
            if s.symbolGrid[row][col] == _wild {
                count++
                positions = append(positions, &position{Row: row, Col: col})
            }
        }
        
        // 该列无百搭 → 中断
        if count == 0 {
            if col >= _minMatchCount {
                return &winInfo{Symbol: symbol, SymbolCount: col, LineCount: lineCount}, true
            }
            return nil, false
        }
        
        lineCount *= count
        
        // 到达最后一列
        if col == _colCount-1 {
            return &winInfo{Symbol: symbol, SymbolCount: _colCount, LineCount: lineCount}, true
        }
    }
    
    return nil, false
}
```

**说明**：
- **只统计纯百搭符号**
- 不与其他符号混合
- 百搭可以独立中奖

### 3. processWinInfos() - 计算中奖倍率

```go
func (s *betOrderService) processWinInfos() {
    var winResults []*winResult
    var winGrid int64Grid
    totalLineMultiplier := int64(0)
    
    for _, info := range s.winInfos {
        // 1. 获取基础倍率（从 PayTable）
        baseMultiplier := s.getSymbolMultiplier(info.Symbol, info.SymbolCount)
        
        // 2. 计算总倍率 = 基础倍率 × Ways倍数
        totalMultiplier := baseMultiplier * info.LineCount
        
        // 3. 构建中奖位置网格
        winPositions := s.buildWinPositions(info, &winGrid)
        
        // 4. 构建中奖结果
        winResults = append(winResults, &winResult{
            Symbol:             info.Symbol,
            SymbolCount:        info.SymbolCount,
            LineCount:          info.LineCount,
            BaseLineMultiplier: baseMultiplier,
            TotalMultiplier:    totalMultiplier,
            WinPositions:       winPositions,
        })
        
        // 5. 累加总倍率
        totalLineMultiplier += totalMultiplier
    }
    
    s.lineMultiplier = totalLineMultiplier
    s.stepMultiplier = totalLineMultiplier
    s.winResults = winResults
    s.winGrid = &winGrid
}
```

**关键点**：
- **基础倍率**：从配置的 `pay_table` 读取
- **Ways 倍数**：每列匹配数量的乘积
- **总倍率**：基础倍率 × Ways 倍数
- **最终奖金**：下注金额 × 总倍率

---

## 🎰 Ways 玩法详解

### 什么是 Ways？

**传统老虎机**：固定的支付线（如 9 线、20 线）  
**Ways 玩法**：所有可能的符号组合路径

### Ways 计算公式

```
Ways倍数 = 第1列匹配数 × 第2列匹配数 × 第3列匹配数 × ...
```

### 详细示例

#### 示例 1：简单 Ways
```
符号 3 的中奖：
  [3]  [3]  [3]  [8]
  [1]  [3]  [4]  [2]
  [5]  [3]  [5]  [7]
  [7]  [1]  [6]  [6]
   ↓    ↓    ↓    ↓
   1    3    1    0 → 中断

Ways = 1 × 3 × 1 = 3
基础倍率 = 2（3列符号3）
总倍率 = 2 × 3 = 6
```

可能的中奖路径（3条）：
1. [0,0] → [1,1] → [0,2] ✅
2. [0,0] → [1,1] → [1,2] ✅  
3. [0,0] → [1,1] → [2,2] ✅

#### 示例 2：复杂 Ways
```
符号 5 的中奖：
  [5]  [5]  [5]  [5]  [9]
  [5]  [5]  [5]  [5]  [1]
  [7]  [5]  [5]  [6]  [8]
  [8]  [4]  [5]  [5]  [3]
   ↓    ↓    ↓    ↓    ↓
   2    3    4    3    0 → 中断

Ways = 2 × 3 × 4 × 3 = 72
基础倍率 = 7（4列符号5）
总倍率 = 7 × 72 = 504
```

#### 示例 3：百搭增强 Ways
```
符号 8 的中奖：
  [8]  [10] [8]  [5]
  [3]  [8]  [10] [3]
  [6]  [8]  [5]  [4]
  [7]  [1]  [6]  [6]
   ↓    ↓    ↓    ↓
   1   2+1   1+1   0 → 中断
      (百搭)  (百搭)

Ways = 1 × 2 × 2 = 4
基础倍率 = 15（3列符号8）
总倍率 = 15 × 4 = 60
```

**百搭的作用**：
- ✅ 增加该列的匹配数量
- ✅ 增加 Ways 倍数
- ✅ 提高中奖金额

---

## 💰 奖金计算

### 计算公式

```
最终奖金 = BaseMoney × Multiple × TotalMultiplier

其中：
- BaseMoney：基础下注（如 1元）
- Multiple：倍数（如 1倍）
- TotalMultiplier：总倍率（所有中奖倍率之和）
```

### 示例

#### 单个符号中奖
```
符号 8 中奖：
- 匹配列数：3列
- Ways：4
- 基础倍率：15
- 总倍率：15 × 4 = 60

下注：1元 × 1倍 = 1元
奖金：1 × 60 = 60元
```

#### 多个符号中奖
```
符号 3 中奖：倍率 = 2 × 3 = 6
符号 5 中奖：倍率 = 4 × 1 = 4
符号 6 中奖：倍率 = 6 × 2 = 12
------------------------------------
总倍率 = 6 + 4 + 12 = 22

下注：1元 × 1倍 = 1元
奖金：1 × 22 = 22元
```

---

## 🎁 免费游戏机制

### 触发条件

#### 基础游戏中触发
```go
// 统计夺宝符号（ID=11）数量
treasureCount := s.countSymbol(_treasure)

// 检查是否 ≥ 3个
if treasureCount >= _triggerTreasureCount {
    // 计算免费次数
    extraScatters := treasureCount - 3
    freeCount := FreeGameInitTimes + (extraScatters × ExtraScatterExtraTime)
    
    // 设置免费次数
    SetFreeNum(freeCount)
}
```

**触发规则**：
| 夺宝符号数量 | 免费次数 | 计算公式 |
|--------------|----------|----------|
| 3个 | 10次 | 10 + (0×2) = 10 |
| 4个 | 12次 | 10 + (1×2) = 12 |
| 5个 | 14次 | 10 + (2×2) = 14 |
| ...更多 | 更多 | 10 + ((n-3)×2) |

#### 免费游戏中追加
```go
// 免费游戏中每个夺宝符号增加2次免费次数
if treasureCount > 0 {
    addFreeCount := treasureCount × ExtraScatterExtraTime
    newFreeNum := currentFreeNum + addFreeCount
    SetFreeNum(newFreeNum)
}
```

**追加规则**：
- 每个夺宝符号：+2次免费
- 可以无限追加
- 示例：免费游戏中出现 3个夺宝 → +6次

### 免费游戏特性

1. **不扣费**：使用基础游戏的下注金额
2. **独立统计**：`FreeTotalMoney` 单独记录
3. **可追加**：免费游戏中可继续触发
4. **独立 RealData**：使用 `roll_cfg.free` 的配置

---

## 🎲 符号生成逻辑

### RealData 结构

```json
"real_data": [
    // 索引 0：基础游戏数据
    [
        [1,2,3,3,3,4,4,9,1,8,...],  // 第1列（120个符号）
        [3,9,5,4,9,4,3,8,4,3,...],  // 第2列（120个符号）
        [6,3,3,4,5,5,2,8,4,4,...],  // 第3列（120个符号）
        [8,9,3,4,5,1,9,8,9,1,...],  // 第4列（120个符号）
        [1,3,3,4,5,6,1,8,9,11,...]  // 第5列（120个符号）
    ],
    // 索引 1：免费游戏数据
    [...]
]
```

### 生成算法

```go
func (s *betOrderService) initSpinSymbol() [20]int64 {
    // 1. 选择 RealData（基础/免费）
    if s.isFree {
        rollCfg = s.gameConfig.RollCfg.Free  // 使用免费游戏配置
    } else {
        rollCfg = s.gameConfig.RollCfg.Base  // 使用基础游戏配置
    }
    
    // 2. 根据权重随机选择 RealData 索引
    realIndex := weightedRandom(rollCfg.UseKey, rollCfg.Weight)
    realData := s.gameConfig.RealData[realIndex]
    
    // 3. 为每列随机选择起始位置
    var symbols [20]int64
    for col := 0; col < 5; col++ {
        columnData := realData[col]  // 该列的 120 个符号
        startIndex := rand.IntN(120) // 随机起始位置
        
        // 4. 从起始位置连续取 4 个符号
        for row := 0; row < 4; row++ {
            index := (startIndex + row) % 120
            symbols[row*5 + col] = columnData[index]
        }
    }
    
    return symbols
}
```

**关键点**：
- 每列独立随机起始位置
- 从起始位置连续取 4 个符号
- 循环取值（末尾接开头）

### 生成示例

```
第1列 RealData：[1,2,3,3,3,4,4,9,1,8,...]（120个）
起始位置：55

取值：
- symbols[0*5+0] = columnData[55]  → 符号A
- symbols[1*5+0] = columnData[56]  → 符号B
- symbols[2*5+0] = columnData[57]  → 符号C
- symbols[3*5+0] = columnData[58]  → 符号D

结果：
  [A]  ...
  [B]  ...
  [C]  ...
  [D]  ...
```

---

## 🎯 完整游戏示例

### 基础游戏示例

#### 输入
```
下注：1元 × 1倍 = 1元
```

#### 生成符号
```
  [9]  [11] [1]  [3]  [10]
  [3]  [9]  [2]  [7]  [9]
  [4]  [7]  [3]  [8]  [11]
  [5]  [3]  [10] [9]  [2]
```

#### 中奖判断

**符号 3**：
- 第1列：1个（位置 [1,0]）
- 第2列：1个（位置 [3,1]）
- 第3列：1个（位置 [2,2]） + 1个百搭（位置 [3,2]）= 2个
- 第4列：0个 → 中断
→ Ways = 1×1×2 = 2  
→ 基础倍率 = 2  
→ 总倍率 = 2×2 = 4

**符号 9**：
- 第1列：1个（位置 [0,0]）
- 第2列：1个（位置 [1,1]）
- 第3列：0个 → 中断（只有2列）
→ 不中奖（需要至少3列）

**夺宝符号（11）**：
- 统计：2个（位置 [0,1], [2,4]）
- 不参与中奖，不触发免费（需要≥3个）

#### 输出
```
中奖结果：
- 符号 3：Ways=2, 倍率=4

总倍率：4
奖金：1元 × 4 = 4元
```

---

### 免费游戏触发示例

#### 输入
```
下注：1元 × 1倍 = 1元
```

#### 生成符号
```
  [11] [3]  [8]  [11] [9]
  [3]  [9]  [2]  [7]  [9]
  [4]  [7]  [3]  [8]  [11]
  [5]  [11] [10] [9]  [2]
   ↓         ↓         ↓
 夺宝1     夺宝2     夺宝3、夺宝4
```

#### 中奖判断

**夺宝符号（11）**：
- 统计：4个
- 触发免费游戏！
- 免费次数 = 10 + (4-3)×2 = 12次

#### 输出
```
中奖结果：
- 触发免费游戏！
- 免费次数：12次
- 其他符号的正常中奖...
```

---

## 🔥 免费游戏示例

### 免费游戏第1次

#### 输入
```
免费次数：12 → 11
下注：使用基础游戏的1元
```

#### 生成符号（使用免费游戏 RealData）
```
  [8]  [8]  [8]  [10] [9]
  [8]  [8]  [8]  [8]  [1]
  [3]  [11] [5]  [2]  [2]
  [5]  [3]  [6]  [3]  [3]
```

#### 中奖判断

**符号 8**：
- 第1列：2个
- 第2列：2个
- 第3列：2个
- 第4列：2个（1个符号8 + 1个百搭）
- 第5列：0个 → 中断
→ Ways = 2×2×2×2 = 16  
→ 基础倍率 = 20（4列）  
→ 总倍率 = 20×16 = 320

**夺宝符号（11）**：
- 统计：1个
- 追加免费次数：1×2 = 2次
- 新免费次数：11 + 2 = 13次

#### 输出
```
中奖结果：
- 符号 8：Ways=16, 倍率=320
- 追加免费：+2次（现在剩余 13次）

奖金：1元 × 320 = 320元（累加到免费总奖金）
```

---

## 📊 关键变量说明

### winInfo - 中奖信息
```go
type winInfo struct {
    Symbol      int64       // 中奖符号ID（1-10）
    SymbolCount int64       // 匹配的列数（3-5）
    LineCount   int64       // Ways 倍数
    Positions   []*position // 中奖位置列表
}
```

### winResult - 中奖结果
```go
type winResult struct {
    Symbol             int64      // 中奖符号ID
    SymbolCount        int64      // 匹配的列数
    LineCount          int64      // Ways 倍数
    BaseLineMultiplier int64      // 基础倍率（从 PayTable）
    TotalMultiplier    int64      // 总倍率 = 基础倍率 × Ways
    WinPositions       int64Grid  // 中奖位置网格（1表示中奖）
}
```

---

## 🎯 核心逻辑总结

### 中奖逻辑
1. ✅ **Ways 玩法**：连续列匹配，Ways = 各列匹配数相乘
2. ✅ **百搭增强**：百搭可以替代任何符号，增加 Ways
3. ✅ **倍率计算**：基础倍率（PayTable）× Ways倍数
4. ✅ **多符号中奖**：所有符号的倍率累加

### Wild（百搭）机制
1. ✅ **替代功能**：可以替代符号 1-9（不能替代夺宝11）
2. ✅ **增加 Ways**：增加该列的匹配数量
3. ✅ **独立中奖**：连续百搭也可以独立中奖
4. ✅ **最高倍率**：20/30/50

### 免费游戏触发
1. ✅ **基础触发**：≥3个夺宝符号 → 10次免费
2. ✅ **额外次数**：每多1个夺宝 → +2次
3. ✅ **免费追加**：免费游戏中每个夺宝 → +2次
4. ✅ **无限追加**：理论上可以无限触发

---

## 🔍 代码质量

### ✅ 优点
- 逻辑清晰，结构合理
- Ways 玩法实现正确
- 百搭机制完善
- 免费游戏功能完整

### ⚠️ 当前问题
- RealData 配置质量差
- 需要使用数值策划的正式数据

---

## 📝 配置说明

### 当前配置
```json
{
    "pay_table": [[2,3,5], [2,3,5], ...],  // 倍率表
    "free_game_trigger_scatter": 3,        // 触发免费需要3个夺宝
    "free_game_init_times": 10,            // 基础10次免费
    "extra_scatter_extra_time": 2,         // 每多1个夺宝+2次
    "real_data": [...]                     // 符号数据
}
```

**需要优化**：
- 使用数值策划的正式 RealData
- 达到目标 RTP 89.13%

---

*逻辑分析完成时间：2025-10-29*

