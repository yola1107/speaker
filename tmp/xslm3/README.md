# XSLM2 - 血色浪漫2

## 📋 基本信息

| 项目 | 值 |
|------|---|
| **游戏ID** | 18892 |
| **类型** | 老虎机 (Slot) |
| **网格** | 4行×5列 |
| **玩法** | 576 Ways |

---

## 🎲 符号赔率表（从低到高）

| ID | 符号 | 3连 | 4连 | 5连 |
|----|------|-----|-----|-----|
| 1 | 方块 ♦ | 2 | 3 | 5 |
| 2 | 梅花 ♣ | 2 | 3 | 5 |
| 3 | 红桃 ♥ | 2 | 3 | 5 |
| 4 | 黑桃 ♠ | 2 | 3 | 5 |
| 5 | 木桩 | 3 | 6 | 9 |
| 6 | 十字架 | 5 | 10 | 15 |
| **7** | **女性A** | **8** | **12** | **20** |
| **8** | **女性B** | **8** | **12** | **20** |
| **9** | **女性C** | **8** | **12** | **20** |
| 10 | 女性A百搭 | 10 | 15 | 25 |
| 11 | 女性B百搭 | 10 | 15 | 25 |
| 12 | 女性C百搭 | 10 | 15 | 25 |
| 13 | 🎭 **百搭** | - | - | - |
| 14 | 🌙 **夺宝** | - | - | - |

---

## ⚙️ 符号替换规则

### 基本规则

```
百搭(13): 可替换 1-12 所有符号

女性百搭:
  10 → 只能替换 7(女性A)
  11 → 只能替换 8(女性B)
  12 → 只能替换 9(女性C)
  女性百搭之间不能相互替换
```

### ⚠️ 特殊规则（重要）

由于女性百搭(10-12)可能出现在任意列，不同于普通Ways玩法，需要特别处理：

#### 规则1: 女性百搭可以不在第一列

**示例：百搭居首，女性百搭在后**
```
     列0  列1  列2  列3  列4
行0: 13   13   10    1    1      ← 查找符号10时
行1: 13   13   10    1    1         列0: 13(百搭) ✓
行2: 13   13   10    1    1         列1: 13(百搭) ✓
行3:  1    1    1    1    1         列2: 10(真正的女性百搭) ✓

判断: 列0-2连续，且有真正的符号10出现
结果: 符号10中奖 ✓ (3列, Ways=3×3×3=27)
```

**关键**: 使用 `exist` 标志确保至少有一个真正的女性百搭符号出现

#### 规则2: 女性百搭不能相互替换

```
10 不能替换 11、12
11 不能替换 10、12
12 不能替换 10、11

但 13(百搭) 可以替换 10、11、12
```

**示例：女性百搭互不替换**
```
     列0  列1  列2  列3  列4
行0: 10   11   12    1    1      ← 查找符号10时
行1: 10   11   12    1    1         列0: 10 ✓
行2: 10   11   12    1    1         列1: 11 ✗ (不能替换)
行3:  1    1    1    1    1         断线

结果: 符号10不中奖 (只有1列)
```

#### 规则3: 普通符号和女性百搭分开计算

```
查找符号1-6(普通符号):
  • 可被 13(百搭) 替换
  • 不可被 10-12(女性百搭) 替换

查找符号7-9(女性符号):
  • 可被 13(百搭) 替换
  • 可被对应的女性百搭替换 (7→10, 8→11, 9→12)
  • 不可被其他女性百搭替换

查找符号10-12(女性百搭):
  • 可被 13(百搭) 替换
  • 不可被其他女性百搭替换
  • 必须有真正的符号出现 (exist标志)
```

---

## 🎮 游戏规则

### 基础规则

**中奖方式**: 576 Ways（从左到右连续出现3个及以上相同符号）

**投注计算**: `投注金额 = 基础金额 × 倍数 × 20`

**示例**: 基础0.02 × 倍数5 × 20 = **2.00**

---

### 🔄 消除机制详解

#### 一、基础模式消除流程

**单次请求流程（一个Step）**:

```
┌─────────────────────────────────────────────────────┐
│ 客户端调用 BetOrder                                  │
└─────────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────┐
│ Step 1: Spin → 生成4×5符号网格                       │
└─────────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────┐
│ Step 2: 查找中奖                                     │
│   • 从左到右扫描每个符号(1-12)                        │
│   • 计算 Ways 和倍数                                 │
└─────────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────┐
│ Step 3: 判断是否触发连消                             │
│   条件1: 有女性符号中奖(7-12)？                      │
│   条件2: 盘面上有百搭符号(13)？                      │
└─────────────────────────────────────────────────────┘
         │                                    │
    两个条件都满足                        任一条件不满足
         ↓                                    ↓
┌──────────────────────┐          ┌──────────────────────┐
│ 触发连消              │          │ 不触发连消            │
│                      │          │                      │
│ • 只计算女性中奖     │          │ • 计算所有中奖奖金    │
│ • 标记消除位置        │          │ • 检查是否有夺宝      │
│ • 返回结果            │          │ • 回合结束            │
│ isRoundOver=false    │          │ isRoundOver=true     │
└──────────────────────┘          └──────────────────────┘
         │                                    │
         ↓                                    ↓
┌──────────────────────┐          ┌──────────────────────┐
│ 客户端收到结果        │          │ 客户端收到结果        │
│ 发现未结束            │          │ 发现已结束            │
│ 再次调用 BetOrder    │          │ 停止调用              │
│ → 消除下落填充       │          │                      │
└──────────────────────┘          └──────────────────────┘

* 消除下落机制（重要）: 
  - 首次Spin: 完整生成网格
  - 有中奖: 当前调用完成消除→下落→填充，保存NextSymbolGrid
  - 返回给客户端: 原始网格（用于动画显示）
  - 下次调用: 直接使用NextSymbolGrid（已处理好的网格）
```

**重要说明 - 客户端与服务端交互**:

```
客户端第1次请求（回合开始）:
  → BetOrder(baseMoney=0.02, multiple=5)
  
服务端处理:
  ✓ 判断: isFirst=true (首次Spin)
  ✓ 扣费: amount=2.00
  ✓ Spin: 生成符号网格A
  ✓ 判断: 女性中奖 + 有百搭 → 触发连消
  ✓ 处理: 消除→下落→填充 → 生成网格B
  ✓ 保存: NextSymbolGrid=网格B到Redis
  ← 返回: symbolGrid=网格A（原始）, isRoundOver=false

客户端收到结果:
  检查 isRoundOver=false → 发现未结束
  
客户端第2次请求（连消Step）:
  → BetOrder(baseMoney=0.02, multiple=5)  ← 需要再次调用！
  
服务端处理:
  ✓ 判断: isFirst=false (连消Step)
  ✓ 扣费: amount=0 (不扣费！)
  ✓ Spin: 使用网格B（上一step处理好的）
  ✓ 判断: 无女性中奖 或 无百搭 → 不触发连消
  ← 返回: symbolGrid=网格B, isRoundOver=true

客户端收到结果:
  检查 isRoundOver=true → 回合结束
```

**关键机制**:
1. **一次请求一个Step**: 一次 BetOrder 调用只处理一个 Step
2. **客户端轮询**: 客户端检查 `isRoundOver`，如果为 false 需要再次调用
3. **服务端识别**: 通过 `isFirst` 自动识别是首次Spin还是连消Step
4. **连消不扣费**: 连消 Step 的 `amount=0`
5. **真正的消除下落**: 
   - 首次Spin: 完整生成符号网格
   - 连消Step: 消除中奖符号 → 符号下落 → 顶部填充新符号

⚠️ **消除下落逻辑**（关键）：
```go
Step 1 (首次):
  ① 生成网格A: [7,7,7,13,13,...]
  ② 查找中奖 → 女性A中奖
  ③ 触发连消 → isRoundOver=false
  ④ 消除网格A中奖符号 → [_,_,_,_,_,...]
  ⑤ 符号下落 → 符号下移填补空位
  ⑥ 填充新符号 → 网格B: [新,新,新,...]
  ⑦ 保存到Redis: NextSymbolGrid=网格B（下落后的）
  ⑧ 返回: symbolGrid=网格A（原始，给客户端动画）

Step 2 (连消):
  ① 加载: NextSymbolGrid=网格B（上一step处理好的）
  ② symbolGrid=网格B（直接使用）
  ③ 查找中奖
  ④ 无中奖 → isRoundOver=true
  ⑤ 返回: symbolGrid=网格B
```

**时序关键点**:
- ✅ 消除下落在**当前调用**完成
- ✅ 保存**下落后的网格**给下一step
- ✅ 返回**原始网格**给客户端播放动画
- ✅ 下一次调用直接使用下落后的网格

**消除规则**:
- ✅ 必须**同时满足**两个条件才触发连消
- ✅ 只消除**中奖路径上的符号**（通过winGrid标记）
- ✅ 只计算女性符号奖金（`partialElimination=true`，跳过普通符号奖金）
- ⚠️ 有夺宝符号时，中奖路径上的百搭也不消除

**示例1: 触发连消**
```
起始符号:
     列0  列1  列2  列3  列4
行0:  7    7    7    1    1      ← 女性A中奖(3列)
行1:  1   13    1    1    1
行2: 13    1   13    1    1      ← 盘面上有百搭符号
行3:  1    1    1    1    1

消除符号:
     列0  列1  列2  列3  列4
行0: ^7   ^7   ^7    1    1      ← 女性A中奖路径
行1:  1  ^13    1    1    1      ← 百搭参与中奖
行2:^13    1  ^13    1    1      ← 百搭参与中奖
行3:  1    1    1    1    1

判断: 女性中奖✓ + 百搭存在✓ → 触发连消
结果: isRoundOver=false → 客户端再次调用（下次消除下落）
```

**示例2: 不触发连消**
```
起始符号:
     列0  列1  列2  列3  列4
行0:  7    7    7    1    1      ← 女性A中奖(3列)
行1:  8    8    1    1    1
行2:  1    1    1    1    1      ← 盘面无百搭符号
行3:  1    1    1    1    1

消除符号:
     （无符号消除）

判断: 女性中奖✓ + 百搭存在✗ → 不触发连消
结果: 不消除 → isRoundOver=true → 回合结束
```

**示例3: 夺宝保护百搭**
```
起始符号:
     列0  列1  列2  列3  列4
行0:  7    7    7    1    1      ← 女性A中奖(3列)
行1:  1   13    1    1    1
行2: 13   14   13    1    1      ← 盘面上有百搭和夺宝
行3:  1    1    1    1    1

消除符号:
     列0  列1  列2  列3  列4
行0: ^7   ^7   ^7    1    1      ← 女性A中奖路径
行1:  1   13    1    1    1      ← 百搭在中奖路径，但因夺宝保护
行2: 13   14   13    1    1      ← 百搭和夺宝都保留
行3:  1    1    1    1    1

判断: 女性中奖✓ + 百搭存在✓ + 夺宝保护 → 触发连消
结果: isRoundOver=false → 客户端再次调用（下次消除下落）
说明: 盘面有夺宝时winGrid中的百搭不标记消除，下一step下落时百搭保留
```

---

#### 二、免费模式消除流程

**女性符号收集系统**:
```
┌─────────────────────────────────────────────────────┐
│ 收集机制:                                            │
│   每个Step中奖的女性符号 → 累计到收集计数            │
│                                                     │
│   女性A: 0 → 1 → 2 → ... → 10 ✓                    │
│   女性B: 0 → 1 → 2 → ... → 10 ✓                    │
│   女性C: 0 → 1 → 2 → ... → 10 ✓                    │
└─────────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────┐
│ 转换机制:                                            │
│   单个女性符号满10 → 滚轴切换，该女性百搭开始出现    │
│   全部女性符号满10 → 触发【全屏消除模式】            │
└─────────────────────────────────────────────────────┘
```

**免费模式消除流程**:

```
┌─────────────────────────────────────────────────────┐
│ Step 1: Spin → 生成符号网格                          │
│   根据收集状态选择配置: "000"~"111"                  │
└─────────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────┐
│ Step 2: 查找中奖 & 判断消除模式                      │
└─────────────────────────────────────────────────────┘
                      ↓
    ┌─────────────────────────────────────┐
    │ 三种女性符号都≥10？                  │
    └─────────────────────────────────────┘
         │                        │
        是                       否
         ↓                        ↓
    全屏消除模式              部分消除模式
         │                        │
         ↓                        ↓
┌──────────────────┐      ┌──────────────────┐
│ 消除所有中奖符号  │      │ 只消除女性符号    │
│                  │      │                  │
│ 有任意中奖？      │      │ 有女性中奖？      │
│  是 → 继续       │      │  是 → 继续       │
│  否 → 回合结束   │      │  否 → 回合结束   │
└──────────────────┘      └──────────────────┘
```

**两种模式对比**:

| 项目 | 部分消除 (女性<10) | 全屏消除 (女性都≥10) |
|------|-------------------|---------------------|
| **消除内容** | 只消除女性符号(7-12) | 消除所有中奖符号(1-13) |
| **继续条件** | 有女性符号中奖 | 有任意符号中奖 |
| **普通符号** | 中奖但不消除 | 中奖就消除 |
| **百搭符号** | 不消除 | 不消除 |

**示例4: 免费模式-部分消除**
```
收集状态: A=5, B=3, C=7 (未全屏)

起始符号:
     列0  列1  列2  列3  列4
行0:  7    7    7    1    1      ← 女性A中奖(3列)
行1:  1    1    1    1    1
行2: 13   13    1    1    1      ← 盘面上有百搭
行3:  2    2    2    2    2      ← 梅花中奖(5列)

消除符号:
     列0  列1  列2  列3  列4
行0: ^7   ^7   ^7    1    1      ← 女性A消除
行1:  1    1    1    1    1
行2: 13   13    1    1    1      ← 百搭保留
行3:  2    2    2    2    2      ← 梅花保留

判断: 女性中奖✓ → 部分消除模式
结果: 收集A+3 → isRoundOver=false → 客户端再次调用（下次消除下落）
说明: 部分消除只计算女性符号奖金，winGrid只标记女性符号消除
```

**示例5: 免费模式-全屏消除**
```
收集状态: A=10, B=10, C=10 (全屏消除)

起始符号:
     列0  列1  列2  列3  列4
行0:  7    7    7    1    1      ← 女性A中奖(3列)
行1:  1    1    1    1    1
行2:  2    2    2    2    2      ← 梅花中奖(5列)
行3:  3    3    3    3    1      ← 红桃中奖(4列)

消除符号:
     列0  列1  列2  列3  列4
行0: ^7   ^7   ^7    1    1      ← 女性A消除
行1:  1    1    1    1    1
行2: ^2   ^2   ^2   ^2   ^2      ← 梅花消除
行3: ^3   ^3   ^3   ^3    1      ← 红桃消除

判断: 全屏消除✓ + 有中奖✓ → 触发连消
结果: isRoundOver=false → 客户端再次调用（下次消除下落）
说明: 全屏消除模式计算所有中奖奖金，winGrid标记所有中奖符号消除
```

---

#### 三、免费游戏触发

**基础模式触发**:

| 夺宝数量 | 免费次数 |
|---------|---------|
| 3个 | 7次 |
| 4个 | 10次 |
| 5个 | 15次 |

**免费模式额外奖励**:
- 每出现1个夺宝符号 → 免费次数+1
- 回合结束时统计夺宝数量

**场景数据持久化**:
```
进入免费游戏时:
  • 从Redis读取女性符号收集进度
  • 恢复到 spin 结构体

免费游戏进行中:
  • 每个Step结束后保存收集进度到Redis
  • 确保断线重连后数据不丢失

免费游戏结束后:
  • 清空Redis中的收集数据
  • 重置计数为 [0,0,0]
```

---

## 🏗️ 技术实现

### 核心特性

#### 1. 动态符号生成 ⭐

**替代 Redis 预设数据**，使用配置驱动：

```go
// 基础模式: 使用 roll_cfg.base
// 免费模式: 根据女性符号收集状态选择配置
//   "000" → 三种都未满10
//   "001" → 只有C满10
//   "111" → 三种都满10（全屏消除）

symbolGrid := _cnf.initSpinSymbol(isFreeRound, femaleCounts)
```

#### 2. 场景数据持久化

```go
// Redis 存储结构
type SpinSceneData struct {
    FemaleCountsForFree [3]int64  // [A计数, B计数, C计数]
}

// Key: game:scene:{gameId}:{memberId}
// TTL: 90天
```

#### 3. 滚轴配置切换

免费模式根据收集状态动态选择配置：

| 收集状态 | Key | 说明 |
|---------|-----|------|
| A=5,B=3,C=7 | "000" | 都未满10 |
| A=10,B=5,C=7 | "100" | A满10 |
| A=10,B=10,C=7 | "110" | A/B满10 |
| A=10,B=10,C=10 | "111" | 全满10（全屏消除）|  

### 文件结构

```
xslm2/
├── xsl2_const.go              // 常量定义（符号ID、网格尺寸）
├── xsl2_config.go             // 配置管理（动态符号生成、赔率表）
├── xsl2_config_json.go        // 游戏配置JSON（滚轴数据、权重）
├── xsl2_spin.go               // 核心逻辑（Spin、中奖查找、消除下落）
├── xsl2_order.go              // 下注流程（BetOrder入口）
├── xsl2_order_scene.go        // 场景数据管理（Redis持久化）
├── xsl2_order_step.go         // Step处理（奖金计算、免费游戏）
├── xsl2_util.go               // 工具函数（辅助函数）
├── rtp_test.go                // RTP压测（1000万局）
├── README.md                  // 游戏文档（本文件）
└── CODE_SAFETY_REPORT.md      // 代码安全检查报告
```

### 核心流程详解

#### 服务端处理流程（单个Step）

```
┌─────────────────────────────────────────────────────┐
│ 1. 接收请求 (BetOrder)                               │
│    - 获取用户信息、商户信息、游戏配置                 │
│    - 加锁防止并发                                     │
└─────────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────┐
│ 2. 判断Step类型                                      │
│    - 检查上一个订单状态                               │
│    - isFirst = (lastOrder == nil || IsRoundOver)    │
└─────────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────┐
│ 3. 加载场景数据 (reloadScene)                        │
│    - 从Redis读取: FemaleCountsForFree、NextSymbolGrid│
│    - 恢复女性符号收集进度                             │
└─────────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────┐
│ 4. 初始化 & 扣费                                     │
│    - 首次Step: amount = baseMoney × multiple × 20   │
│    - 连消Step: amount = 0 (不扣费)                  │
└─────────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────┐
│ 5. 执行baseSpin (核心逻辑)                           │
│    ① 获取符号网格                                    │
│      • isFirst=true: 动态生成新网格                  │
│      • isFirst=false: 使用NextSymbolGrid（已处理）   │
│    ② 查找中奖 (findWinInfos)                        │
│      • 扫描符号1-9（普通+女性）                       │
│      • 扫描符号10-12（女性百搭）                     │
│    ③ 判断消除模式                                    │
│      • 基础: hasFemaleWin && hasWild → 连消         │
│      • 免费: 部分/全屏消除                           │
│    ④ 计算中奖结果                                    │
│      • partialElimination=true: 只计算女性符号       │
│      • partialElimination=false: 计算所有符号        │
│    ⑤ 消除下落填充（如果未结束）                      │
│      • eliminateSymbols: 标记中奖符号为空白          │
│      • dropSymbols: 符号下落填补空位                 │
│      • fillNewSymbols: 顶部填充新符号                │
│      • 保存到nextSymbolGrid供下一step使用            │
└─────────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────┐
│ 6. 更新订单 & 结算                                   │
│    - 计算奖金: bonusAmount = stepMultiplier × bet   │
│    - 更新余额                                         │
│    - 保存订单到数据库                                 │
└─────────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────┐
│ 7. 保存场景数据 (saveScene)                          │
│    - 保存女性符号计数到Redis                          │
│    - 保存NextSymbolGrid（如果未结束）                │
│    - 免费游戏结束时清空场景                           │
└─────────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────┐
│ 8. 返回结果给客户端                                  │
│    - symbolGrid: 原始网格（用于动画）                │
│    - winResults: 中奖详情                            │
│    - isRoundOver: 是否结束（客户端判断是否继续）     │
└─────────────────────────────────────────────────────┘
```

#### 消除下落填充流程（applyEliminationAndDrop）

```
输入: lastGrid (上一step的网格), lastWinGrid (中奖标记)

Step 1: 复制网格
┌──────────────────────────────────────┐
│ newGrid = lastGrid (深拷贝)          │
└──────────────────────────────────────┘

Step 2: 消除中奖符号 (eliminateSymbols)
┌──────────────────────────────────────┐
│ 遍历winGrid中标记的位置:              │
│   • winGrid[r][c] != 0 → 中奖位置    │
│   • 检查保护规则:                     │
│     - 夺宝符号: 不消除                │
│     - 百搭符号: 免费模式/有夺宝时不消除│
│   • 消除: newGrid[r][c] = 0 (_blank) │
│                                      │
│ 返回: eliminatedCount (消除数量)     │
└──────────────────────────────────────┘

Step 3: 符号下落 (dropSymbols)
┌──────────────────────────────────────┐
│ 按列处理（列0到列4）:                 │
│   从底部往顶部扫描:                   │
│     • 找到非空符号 → 移到底部writePos │
│     • 空白符号保留在顶部               │
│                                      │
│ 结果: 空白符号全部移到顶部            │
└──────────────────────────────────────┘
        ↓ 示例:
    消除前      下落后
    0  1  2    1  2  3  ← 非空符号下移
    0  2  3    0  0  0  ← 空白在顶部
    1  0  4

Step 4: 填充新符号 (fillNewSymbols)
┌──────────────────────────────────────┐
│ 遍历网格:                             │
│   如果 newGrid[r][c] == 0:           │
│     • 从配置中随机生成符号             │
│     • 根据femaleCountsForFree选配置   │
│     • newGrid[r][c] = 新符号          │
└──────────────────────────────────────┘
        ↓ 示例:
    下落后      填充后
    0  0  0    5  7  2  ← 随机生成
    1  2  3    1  2  3  
    4  5  6    4  5  6

输出: newGrid (处理完成的网格), eliminatedCount
```

---

## 🛡️ 安全机制

### 死循环保护

#### 1. 消除计数检查
```go
// xsl2_spin.go:baseSpin()
if eliminatedCount == 0 {
    // 触发连消但无符号可消除 → 强制结束回合
    global.GVA_LOG.Warn("no symbols eliminated but round not over")
    s.isRoundOver = true
}
```

**场景**: 免费模式下，女性符号中奖但全是百搭替换，百搭因保护规则不被消除
- **保护**: 检测到0个符号被消除 → 强制结束回合
- **日志**: WARN级别，记录触发条件

#### 2. 最大步数限制
```go
// rtp_test.go
maxCascadeSteps := 50  // 压测中的安全上限
if cascadeCount >= maxCascadeSteps {
    break // 强制退出
}
```

### 边界检查

#### 1. 数组越界保护
```go
// xsl2_config.go
// 配置索引边界检查
if idx < 0 || idx >= len(c.RealData) {
    idx = 0  // 使用默认配置
}
if col < 0 || col >= len(c.RealData[idx]) {
    col = 0  // 使用默认列
}
```

#### 2. 空指针检查
```go
// xsl2_spin.go
// Grid操作前的nil检查
if grid == nil || winGrid == nil {
    return 0
}
```

### 调试日志

#### ERROR级别
**`nextGrid is nil in non-first step`**
```
触发条件: 连消step时nextGrid参数为nil
正常情况: 不应该出现（说明状态管理有bug）
记录信息: isFreeRound, isFirst, femaleCountsForFree
```

#### WARN级别
**`no symbols eliminated but round not over`**
```
触发条件: 触发连消但没有符号被消除
正常情况: 不应该出现（逻辑判断错误）
记录信息: isFreeRound, hasFemaleWin, enableFullElimination, winResultsCount
自动处理: 强制结束回合，防止死循环
```

---

## 🧪 测试

### RTP测试

```bash
cd game/xslm2
go test -run TestRtp
```

**测试规模**:
- 1000万局（10,000,000局）
- 基础模式 + 免费模式
- 预计耗时: 10-20分钟（取决于CPU）

**测试报告内容**:
```
【基础模式统计】
  总局数: 10000000
  总投注: 200000000.00
  总奖金: xxxxx.xx
  RTP: xx.xx%
  中奖局数: xxxxx (xx.xx%)
  平均连消步数: x.xx
  最大连消步数: xx

【连消机制统计】
  Wild触发连消: xxxxx次 (xx.xx%)
  女性+Wild组合: xxxxx次 (xx.xx%)

【夺宝符号统计】
  3个夺宝: xxxxx次 → 预期xxxxx次免费
  4个夺宝: xxxxx次 → 预期xxxxx次免费
  5个夺宝: xxxxx次 → 预期xxxxx次免费
  免费触发次数: xxxxx (xx.xx%)

【免费模式统计】
  总局数: xxxxxxx
  总奖金: xxxxx.xx
  RTP: xx.xx%
  中奖局数: xxxxx (xx.xx%)
  有连消局数: xxxxx (xx.xx%)
  无连消局数: xxxxx (xx.xx%)

【全屏消除统计】
  触发次数: xxxxx
  触发率: xx.xx%

【免费次数核算】
  理论总免费次数: xxxxx (基础xxxxx + 额外xxxxx)
  实际玩的免费次数: xxxxx
  差异: xx (xx.xx%)

【总计】
  总投注金额: 200000000.00
  总奖金金额: xxxxx.xx
  总回报率(RTP): xx.xx%
  基础贡献: xx.xx% | 免费贡献: xx.xx%
```

### 调试开关

```go
// rtp_test.go
const (
    testRounds       = 1e7   // 测试局数
    progressInterval = 1e5   // 进度输出间隔
    debugFileOpen    = false // 调试文件输出（详细信息）
)

// 开启调试输出
debugFileOpen = true  // 会生成 logs/xslm2_rtp_yyyymmdd_hhmmss.txt
```

**调试文件内容**:
- 每一局的符号网格
- 中奖信息详情
- 连消步骤追踪
- 女性符号收集进度
- 全屏消除触发记录

---

## 🚀 快速开始

### 基础调用

```go
req := &request.BetOrderReq{
    GameId:     18892,
    BaseMoney:  0.02,
    Multiple:   5,
}
result, err := xslm2.BetOrder(req)
```

### 返回结果说明

```json
{
  "orderSN": "订单号",
  "currentBalance": 123.45,
  "baseBet": 0.02,
  "multiplier": 5,
  "betAmount": 2.0,
  "symbolGrid": [
    [7, 7, 7, 1, 1],
    [1, 13, 1, 1, 1],
    [13, 1, 13, 1, 1],
    [1, 1, 1, 1, 1]
  ],
  "winGrid": [
    [7, 7, 7, 0, 0],
    [0, 13, 0, 0, 0],
    [13, 0, 13, 0, 0],
    [0, 0, 0, 0, 0]
  ],
  "winResults": [
    {
      "symbol": 7,
      "symbolCount": 3,
      "lineCount": 27,
      "baseLineMultiplier": 8,
      "totalMultiplier": 216
    }
  ],
  "bonusAmount": 4.32,
  "stepMultiplier": 216,
  "isRoundOver": false,
  "hasFemaleWin": true,
  "isFreeRound": false,
  "newFreeRoundCount": 0,
  "totalFreeRoundCount": 0,
  "remainingFreeRoundCount": 0,
  "femaleCountsForFree": [0, 0, 0],
  "nextFemaleCountsForFree": [0, 0, 0],
  "enableFullElimination": false
}
```

### 字段说明

| 字段 | 类型 | 说明 |
|------|-----|------|
| `symbolGrid` | `[][]int64` | 符号网格（4×5） |
| `winGrid` | `[][]int64` | 中奖标记网格（0=未中奖，非0=中奖符号） |
| `winResults` | `[]WinResult` | 中奖详情数组 |
| `bonusAmount` | `float64` | 本Step奖金 |
| `stepMultiplier` | `int64` | 本Step倍数 |
| `isRoundOver` | `bool` | **关键**: true=回合结束，false=需继续调用 |
| `hasFemaleWin` | `bool` | 是否有女性符号中奖 |
| `isFreeRound` | `bool` | 是否免费回合 |
| `femaleCountsForFree` | `[3]int64` | 女性符号收集进度 [A, B, C] |
| `enableFullElimination` | `bool` | 是否触发全屏消除 |

### 客户端集成示例

```go
// 客户端轮询逻辑
func playRound(req *request.BetOrderReq) {
    for {
        result, err := xslm2.BetOrder(req)
        if err != nil {
            log.Error("BetOrder failed", err)
            break
        }
        
        // 显示动画
        displayAnimation(result.SymbolGrid, result.WinGrid)
        displayWinAmount(result.BonusAmount)
        
        // 检查是否结束
        if result.IsRoundOver {
            log.Info("Round finished")
            break
        }
        
        // 继续下一step
        log.Info("Cascade continues...")
        time.Sleep(500 * time.Millisecond) // 动画延迟
    }
}
```

---

## ⚠️ 注意事项

### 1. 并发安全
- 所有BetOrder调用已加锁（`c.BetLock.Lock()`）
- 同一用户的请求会串行处理
- 无需额外并发控制

### 2. 状态一致性
- **必须检查 `isRoundOver`**: 客户端根据此字段判断是否继续
- **场景数据TTL**: Redis中的场景数据90天有效期
- **断线重连**: 场景数据持久化，支持断线重连

### 3. 扣费机制
- **首次Step**: 扣除完整投注金额
- **连消Step**: 不扣费（`amount=0`）
- **免费游戏**: 完全不扣费

### 4. 性能优化
- 使用对象池 (`sync.Pool`) 管理随机数生成器
- 动态符号生成替代Redis预设数据
- 单次请求时间 < 10ms（正常情况）

### 5. 已知限制
- 最大连消步数: 理论无限，实际RTP测试中最大约20步
- 女性符号收集上限: 每种10个（>=10触发转换）
- 夺宝符号: 1-5个有效，超过5个按5个计算

---

## 📚 相关文档

- **`CODE_SAFETY_REPORT.md`**: 代码安全检查报告（死循环保护、边界检查、空指针保护）
- **`XSLM_VS_XSLM2_COMPARISON.md`**: XSLM与XSLM2对比分析（重构前后对比）
- **`MAHJONG_VS_XSLM2_COMPARISON.md`**: Mahjong与XSLM2对比分析（不同消除机制对比）
- **配置文件**: `xsl2_config_json.go` - 滚轴配置和赔率表

---

## 🔧 故障排查

### 问题1: 连消不触发
**检查**:
- 是否有女性符号(7-12)中奖？
- 盘面上是否有百搭符号(13)？
- 两个条件必须同时满足

### 问题2: 消除后卡住
**检查日志**:
- `WARN: no symbols eliminated but round not over` → 已自动强制结束
- `ERROR: nextGrid is nil in non-first step` → 场景数据异常

### 问题3: 女性符号计数错误
**检查**:
- 只有中奖路径上的女性符号才计入收集
- 女性百搭(10-12)中奖也算女性符号
- 计数上限为10，达到10后不再增加

### 问题4: RTP偏差过大
**正常范围**: ±2% (例如: 设计96% → 实际94%-98%)
**检查**:
- 测试局数是否足够（建议1000万局）
- 基础模式和免费模式RTP分别统计
- 查看连消触发率、全屏消除触发率

---

## 📝 更新日志

### v1.0.0 - 2025-11-06
- ✅ 完整实现血色浪漫2游戏逻辑
- ✅ 动态符号生成（替代Redis预设）
- ✅ 真正的消除下落填充机制
- ✅ 完善的死循环保护
- ✅ 全面的边界检查和空指针保护
- ✅ 详细的调试日志（ERROR/WARN级别）
- ✅ RTP测试（1000万局）
- ✅ 代码安全检查报告

---
